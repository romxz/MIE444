#include <q_config.h>
#include <encoder.h>
#include <init_qmt.h>
#include <math.h>

void initialize(){
  set_tris_b(0b00000000); // sets B to outputs. B0-B1 we want for Roller
  set_tris_c(0b00000000); // sets C to outputs
  set_tris_d(0b11111111); // sets D to inputs
  setup_ccp1(CCP_PWM); // enables CCP1 to PWM mode
  setup_ccp2(CCP_PWM); // enables CCP2 to PWM mode
  setup_timer_2(T2_DIV_BY_1, 255, 1); // sets PWM frequency to 19.5kHz
  setup_adc_ports(ALL_ANALOG); // sets A and E to analog readers to the output from the A/D converter
  setup_adc(ADC_CLOCK_DIV_32); // sets A/D clock frequency
  port_b_pullups(TRUE); // adds "pull up" capability to B. Not sure what this does
}

/*int pwmMotors(int motor, int direction, long int duty){
// two motors:0,1; direction forward/backward:0,1; duty[0,1023]. Return ok,error:0,1
  if (motor==0){ // first motor
    if (direction==0){ // forward direction
      output_low(pin_c3); // pin selected for motor 1 (unsure why c3 and low)
      set_pwm1_duty(duty); // set duty
    } elseif (direction==1){ //backward direction
      output_high(pin_c3); // for backwards c3 needs high instead of low, unsure why
      set_pwm1_duty(1023-duty); // duty seems to be reversed this way
    } else { return 1;}
  } elseif (motor==1){ //second motor
    if (direction==0){ // forward direction
      output_low(pin_c0); // pin selected for motor 2 (unsure why c0 and low)
      set_pwm2_duty(duty); //set duty
    } elseif (direction==1){ // backwards
      output_high(pin_c0); // needs high instead of low, unsure why
      set_pwm2_duty(1023-duty); // duty seems to reverse this way when backwards
    } else { return 1;}
  } else { return 1;}
  return 0;
}*/

/*int onoffMotors(int motor, int state, int direction){
// two motors: 0,1; state off,on:0,1; direction forwards,backwards:0,1; Return ok,error:0,1
  if (motor==0){ // select the pins corresponding to first or second motor
    int left = pin_b4;
    int right = pin_b5;
  } elseif (motor==1){
    int left = pin_b6;
    int right = pin_b7;
  } else { return 1;}
  if (state==0){
      output_low(left);
      output_low(right);
  } elseif (state==1){
    if (direction==0){
      output_low(left);
      output_high(right); 
    } elseif (direction==1){
      output_low(right);
      output_high(left);
    } else { return 1;}
  } else { return 1;}
  return 0;
}*/

int flapControl(int flap, int dir){
  int step = 0;
  int Pin0 = PinStepA0;  // these values need to be changed to match motor's pins
  int Pin1 = PinStepA1; 
  int Pin2 = PinStepA2; 
  int Pin3 = PinStepA3;
  if (flap==0){
    int flapSteps = 175; // Max number of steps forward of the stepper motor A. This number needs to be figured out
    if (dir==1){
      int step = flapSteps mod 7; // Last need to figure out correct syntax for this
    } else { return 1;}
  } elseif (flap==1){
    Pin0 = PinStepB0; // these values need to be changed to match motor's pins
    Pin1 = PinStepB1; 
    Pin2 = PinStepB2; 
    Pin3 = PinStepB3;
    int flapSteps = 175; // Max number of steps forward of the stepper motor B. This number needs to be figured out
    if (dir==1){
      int step = flapSteps mod 7; // Last need to figure out correct syntax for this
    } else { return 1;}
  } else { return 1;}
  int cycle = 0;
  while (cycle<flapSteps){ // flapSteps needs to be calibrated
    if (changeMotorStep(step, Pin0, Pin1, Pin2, Pin3)==1){ return 1;}
    if (dir){ step--; // changes step according to the direction of increasing/decreasing direction
    } else { step++;} 
    if (step>7){ step=0;} // resets the step counter 
    if (step<0){ step=7;} 
    delay(3); // necessary to allow for stepper motor state to settle. NEED to change syntax for qic
    cycle++;
  }
  return 0;
}

int changeMotorStep(int step, int Pin0, int Pin1, int Pin2, int Pin3){ // This function shifts the motor phase to the given step value
  switch(step){ 
    case 0: 
      digitalWrite(Pin0, LOW); // this is in arduino. Need correct syntax for all of these pin state overrides  
      digitalWrite(Pin1, LOW); 
      digitalWrite(Pin2, LOW); 
      digitalWrite(Pin3, HIGH); 
      return 0;  
    case 1: 
      digitalWrite(Pin0, LOW);  
      digitalWrite(Pin1, LOW); 
      digitalWrite(Pin2, HIGH); 
      digitalWrite(Pin3, HIGH); 
      return 0;  
    case 2: 
      digitalWrite(Pin0, LOW);  
      digitalWrite(Pin1, LOW); 
      digitalWrite(Pin2, HIGH); 
      digitalWrite(Pin3, LOW); 
      return 0;  
    case 3: 
      digitalWrite(Pin0, LOW);  
      digitalWrite(Pin1, HIGH); 
      digitalWrite(Pin2, HIGH); 
      digitalWrite(Pin3, LOW); 
      return 0;
    case 4: 
      digitalWrite(Pin0, LOW);  
      digitalWrite(Pin1, HIGH); 
      digitalWrite(Pin2, LOW); 
      digitalWrite(Pin3, LOW); 
      return 0;
    case 5: 
      digitalWrite(Pin0, HIGH);  
      digitalWrite(Pin1, HIGH); 
      digitalWrite(Pin2, LOW); 
      digitalWrite(Pin3, LOW); 
      return 0;
    case 6: 
      digitalWrite(Pin0, HIGH);  
      digitalWrite(Pin1, LOW); 
      digitalWrite(Pin2, LOW); 
      digitalWrite(Pin3, LOW); 
      return 0;
    case 7: 
      digitalWrite(Pin0, HIGH);  
      digitalWrite(Pin1, LOW); 
      digitalWrite(Pin2, LOW); 
      digitalWrite(Pin3, HIGH); 
      return 0;
    default: 
      digitalWrite(Pin0, LOW);  
      digitalWrite(Pin1, LOW); 
      digitalWrite(Pin2, LOW); 
      digitalWrite(Pin3, LOW); 
      return 1;
  }
}

void main(){
  initialize();
}

/* Reading in a entire port (e.g. Port D)
int prtb; // create an 8 bit (0-255) variable to store port information
prtb=input_d(); // input port (each pin represent 1 bit in a binary number
int a; // create a variable to store the bit or pin information
a=bit_test(prtb,0); // return a 0 or 1 corresponding to the pin being high or low of Bit 0
// e.g. if Pin D0 is connected to +5V the variable will equal 1 
*/

*/ Reading a pi (e.g Pin D0)
int reading; // create an 8 bit variable to store pin information
reading=input(pin_d0); // return a 0 or 1 corresponding to the pin being high or low
*/

