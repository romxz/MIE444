#include <q_config.h>
#include <encoder.h>
#include <init_qmt.h>
#include <math.h>

void initialize(){
  set_tris_b(0b00000000); // sets B to outputs. B0-B1 we want for Roller
  set_tris_c(0b00000000); // sets C to outputs
  set_tris_d(0b11111111); // sets D to inputs
  setup_ccp1(CCP_PWM); // enables CCP1 to PWM mode
  setup_ccp2(CCP_PWM); // enables CCP2 to PWM mode
  setup_timer_2(T2_DIV_BY_1, 255, 1); // sets PWM frequency to 19.5kHz
  setup_adc_ports(ALL_ANALOG); // sets A and E to analog readers to the output from the A/D converter
  setup_adc(ADC_CLOCK_DIV_32); // sets A/D clock frequency
  port_b_pullups(TRUE); // adds "pull up" capability to B. Not sure what this does
}

int pwmMotors(int motor, int direction, long int duty){
// two motors:0,1; direction forward/backward:0,1; duty[0,1023]. Return ok,error:0,1
  if (motor==0){ // first motor
    if (direction==0){ // forward direction
      output_low(pin_c3); // pin selected for motor 1 (unsure why c3 and low)
      set_pwm1_duty(duty); // set duty
    } elseif (direction==1){ //backward direction
      output_high(pin_c3); // for backwards c3 needs high instead of low, unsure why
      set_pwm1_duty(1023-duty); // duty seems to be reversed this way
    } else {
      return 1;
    }
  } elseif (motor==1){ //second motor
    if (direction==0){ // forward direction
      output_low(pin_c0); // pin selected for motor 2 (unsure why c0 and low)
      set_pwm2_duty(duty); //set duty
    } elseif (direction==1){ // backwards
      output_high(pin_c0); // needs high instead of low, unsure why
      set_pwm2_duty(1023-duty); // duty seems to reverse this way when backwards
    } else {
      return 1;
    }
  } else {
    return 1;
  }
  return 0;
}

int onoffMotors(int motor, int state, int direction){
// two motors: 0,1; state off,on:0,1; direction forwards,backwards:0,1; Return ok,error:0,1
  if (motor==0){ // select the pins corresponding to first or second motor
    int left = pin_b4;
    int right = pin_b5;
  } elseif (motor==1){
    int left = pin_b6;
    int right = pin_b7;
  } else {
    return 1;
  }
  if (state==0){
      output_low(left);
      output_low(right);
  } elseif (state==1){
    if (direction==0){
      output_low(left);
      output_high(right); 
    } elseif (direction==1){
      output_low(right);
      output_high(left);
    } else {
      return 1;
    }
  } else {
    return 1;
  }
  return 0;
}

void main(){
  initialize();
  
  
}

/* Reading in a entire port (e.g. Port D)
int prtb; // create an 8 bit (0-255) variable to store port information
prtb=input_d(); // input port (each pin represent 1 bit in a binary number
int a; // create a variable to store the bit or pin information
a=bit_test(prtb,0); // return a 0 or 1 corresponding to the pin being high or low of Bit 0
// e.g. if Pin D0 is connected to +5V the variable will equal 1 
*/

*/ Reading a pi (e.g Pin D0)
int reading; // create an 8 bit variable to store pin information
reading=input(pin_d0); // return a 0 or 1 corresponding to the pin being high or low
*/

