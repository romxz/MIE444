#include <q_config.h>
#include <encoder.h>
#include <init_qmt.h>
#include <math.h>

// keeps track of which colors have been detected. 0 means no, 1 means yes
int colorRHere=0; int colorGHere=0; int colorBHere=0; int colorYHere=0;
// keeps track of the colors on the trays. [0,1,2,3]=[R,G,B,Y]. -1 means unassigned, -2 means error
int colorTop=-1; int colorMid=-1; int colorBot=-1;
// need to set up the stepper motor pins, for steppers A and B
int PinStepA0; int PinStepA1; int PinStepA2; int PinStepA3;
int PinStepB0; int PinStepB1; int PinStepB2; int PinStepB3;


void initialize(){
  set_tris_b(0b00000000); // sets B to outputs. B0-B1 we want for Roller
  set_tris_c(0b00000000); // sets C to outputs.
  set_tris_d(0b00000000); // sets D to outputs. Reserved for stepper motors
  PinStepA0 = pin_d0; // dedicate D ports to stepper motors
  PinStepA1 = pin_d1;
  PinStepA2 = pin_d2;
  PinStepA3 = pin_d3;
  PinStepB0 = pin_d4;
  PinStepB1 = pin_d5;
  PinStepB2 = pin_d6;
  PinStepB3 = pin_d7;
  setup_ccp1(CCP_PWM); // enables CCP1 to PWM mode
  setup_ccp2(CCP_PWM); // enables CCP2 to PWM mode
  setup_timer_2(T2_DIV_BY_1, 255, 1); // sets PWM frequency to 19.5kHz
  setup_adc_ports(ALL_ANALOG); // sets A and E to analog readers to the output from the A/D converter
  setup_adc(ADC_CLOCK_DIV_32); // sets A/D clock frequency
  port_b_pullups(TRUE); // adds "pull up" capability to B. Not sure what this does
}

/*int pwmMotors(int motor, int direction, long int duty){
// two motors:0,1; direction forward/backward:0,1; duty[0,1023]. Return ok,error:0,1
  if (motor==0){ // first motor
    if (direction==0){ // forward direction
      output_low(pin_c3); // pin selected for motor 1 (unsure why c3 and low)
      set_pwm1_duty(duty); // set duty
    } elseif (direction==1){ //backward direction
      output_high(pin_c3); // for backwards c3 needs high instead of low, unsure why
      set_pwm1_duty(1023-duty); // duty seems to be reversed this way
    } else { return 1;}
  } elseif (motor==1){ //second motor
    if (direction==0){ // forward direction
      output_low(pin_c0); // pin selected for motor 2 (unsure why c0 and low)
      set_pwm2_duty(duty); //set duty
    } elseif (direction==1){ // backwards
      output_high(pin_c0); // needs high instead of low, unsure why
      set_pwm2_duty(1023-duty); // duty seems to reverse this way when backwards
    } else { return 1;}
  } else { return 1;}
  return 0;
}*/

/*int onoffMotors(int motor, int state, int direction){
// two motors: 0,1; state off,on:0,1; direction forwards,backwards:0,1; Return ok,error:0,1
  if (motor==0){ // select the pins corresponding to first or second motor
    int left = pin_b4;
    int right = pin_b5;
  } elseif (motor==1){
    int left = pin_b6;
    int right = pin_b7;
  } else { return 1;}
  if (state==0){
      output_low(left);
      output_low(right);
  } elseif (state==1){
    if (direction==0){
      output_low(left);
      output_high(right); 
    } elseif (direction==1){
      output_low(right);
      output_high(left);
    } else { return 1;}
  } else { return 1;}
  return 0;
}*/

int flapControl(int flap, int dir){
  int step = 0;
  int Pin0 = PinStepA0;  // these values need to be changed to match motor's pins
  int Pin1 = PinStepA1; 
  int Pin2 = PinStepA2; 
  int Pin3 = PinStepA3;
  if (flap==0){
    int flapSteps = 175; // Max number of steps forward of the stepper motor A. This number needs to be figured out
    if (dir==1){
      int step = flapSteps mod 7; // Last need to figure out correct syntax for this
    } else { return 1;}
  } elseif (flap==1){
    Pin0 = PinStepB0; // these values need to be changed to match motor's pins
    Pin1 = PinStepB1; 
    Pin2 = PinStepB2; 
    Pin3 = PinStepB3;
    int flapSteps = 175; // Max number of steps forward of the stepper motor B. This number needs to be figured out
    if (dir==1){
      int step = flapSteps mod 7; // Last need to figure out correct syntax for this
    } else { return 1;}
  } else { return 1;}
  int cycle = 0;
  while (cycle<flapSteps){ // flapSteps needs to be calibrated
    if (changeMotorStep(step, Pin0, Pin1, Pin2, Pin3)==1){ return 1;}
    if (dir){ step--; // changes step according to the direction of increasing/decreasing direction
    } else { step++;} 
    if (step>7){ step=0;} // resets the step counter 
    if (step<0){ step=7;} 
    delay(3); // necessary to allow for stepper motor state to settle. NEED to change syntax for qic
    cycle++;
  }
  return 0;
}

int changeMotorStep(int step, int Pin0, int Pin1, int Pin2, int Pin3){ 
// This function shifts the motor phase to the given step value
  switch(step){ 
    case 0: 
      output_low(Pin0);
      output_low(Pin1);
      output_low(Pin2);
      output_high(Pin3);
      return 0;  
    case 1: 
      output_low(Pin0);
      output_low(Pin1);
      output_high(Pin2);
      output_high(Pin3);
      return 0;  
    case 2: 
      output_low(Pin0);
      output_low(Pin1);
      output_high(Pin2);
      output_low(Pin3);
      return 0;  
    case 3: 
      output_low(Pin0);
      output_high(Pin1);
      output_high(Pin2);
      output_low(Pin3);
      return 0;
    case 4: 
      output_low(Pin0);
      output_high(Pin1);
      output_low(Pin2);
      output_low(Pin3); 
      return 0;
    case 5: 
      output_high(Pin0);
      output_high(Pin1);
      output_low(Pin2);
      output_low(Pin3); 
      return 0;
    case 6: 
      output_high(Pin0);
      output_low(Pin1);
      output_low(Pin2);
      output_low(Pin3);
      return 0;
    case 7: 
      output_high(Pin0);
      output_low(Pin1);
      output_low(Pin2);
      output_high(Pin3);
      return 0;
    case 8: // this case is reserved for turning the motors off 
      output_low(Pin0);
      output_low(Pin1);
      output_low(Pin2);
      output_low(Pin3);
      return 0;
    default:
      return 1;
  }
}

int determineColor(){ // needs to be implemented
// function reads value from the sensor and designates a value for its output. Returns [0,1,2,3] corresponding to [R,G,B,Y]
  int threshold0=0; //threshold values for each color. Needs to be modified
  int threshold1=0;
  int threshold2=0;
  int threshold3=0;
  long int colorReading=0;
  // colorReading = readPin(X); // reads the sensor pin. X is the sensor input pin. needs to be modified, with correct type too
  // logic for deciding color based on threshold needs to go here. Specific to the sensor
  return colorReading;
}


// does the logic for allowing only the 3 possible colors out of 4, without knowing which to include from the start
// sets the top, middle and bottom trays to be the first three different colors that it finds. Returns -1 for error
int findTray(int color){ // needs to be completed
  int numberOfColors = colorRHere+colorGHere+colorBHere+colorYHere;  // counts how many colors have been detected
  if (numberOfColors<4){
    if (numberOfColors<3){ // raises flag for any new colors found
      switch(color){
        case 0:
          colorRHere=1;
          break;
        case 1:
          colorGHere=1;
          break;
        case 2:
          colorBHere=1;
          break;
        case 3:
          colorYHere=1;
          break;
        default:
        	printf("error:getColor.unrecognizedDeterminedColor;");
          return -1;
      }
    // updates the number of colors after the current color is read
    numberOfColors = colorRHere+colorGHere+colorBHere+colorYHere;
    if ((numberOfColors==1)&(colorTop==-1)){ // first time a new color has been read
      colorTop = colorGHere+(colorBHere)*2+(colorYHere)*3; // assign the top to this first color
    } elseif ((numberOfColors==2)&(colorMid==-1)) { // second time a new color has been read
      colorMid = colorGHere+(colorBHere)*2+(colorYHere)*3-colorTop; // assign the middle to this second color
    } elseif ((numberOfColors==3)&(colorBot==-1)) { // third time a new color has been read
			colorBot = colorGHere+(colorBHere)*2+(colorYHere)*3-colorTop-colorMid; // assign the bottom to this third color
    }
  } else {
  	pintf("error:getColor.numberofColors>4;");
    return -1;
  }
  return color;
}

int nextPage(){ // calls the dc motor to advance one page. needs to be implemented
  return 0;
}

int resetFlap(){ // resets the flaps to the default state. needs to be implemented
  return 0;
}

int senseLight(){ // senses a light threshold to see if there are any pages left. needs to be implemented
  return 101; // value returned needs to be calibrated
}

void main(){
  initialize();
  int lightThreshold = senseLight(); // function that is supposed to sense if there is a colored page via some threshold.
  int pageNumber=0; // page number counter
  int color=0; // this value [0,1,2] stores the color read. 
  int prevColor; // this is to track the previously activated flap
  // try to reset the flaps to default position. optional for later implementation:
  if (resetFlap()==1){ printf("error:main.resetFlap;");}
  } else {
    while (lightThreshold>100&pageNumber<100){
      pageNumber++;
      prevColor = color; // stores the value of the previous color
      // asks sensor threshold function to provide one of the colors, as a value [0,1,2,3] representing [R,G,B,Y]. needs to be implemented
      int color = determineColor();
      color = getColor(); // gets a value of [0,1,2] representing one of the colors in the set, from the sensor
      if (color==-1){ printf("error:getColor;");} // checks there is no error in getColor()
      if ((color!==prevColor)&(prevColor!==0)){ // checks if it needs to close the previously opened flap
        if (flapControl(prevColor-1, 1)==1){ printf("error:main.flapControl.Close;");} // closes the prev. opened flap
      }
      if ((color==1)|(color==2)){ // checks to see if it needs to open a flap
        if (flapControl(color-1, 0)==1){ printf("error:main.flapControl.Open;");} // opens the required flap
      } 
      // feeds the current page into the designated tray:
      if ((-1<color)&(color<3)){ // checks for possible errors in the color range
        if (nextPage()==1){ printf("error:nextPage;");} 
      } else { printf("error:main.color[range];");}
    }
  }
  printf("completed");
}

/* Reading in a entire port (e.g. Port D)
int prtb; // create an 8 bit (0-255) variable to store port information
prtb=input_d(); // input port (each pin represent 1 bit in a binary number
int a; // create a variable to store the bit or pin information
a=bit_test(prtb,0); // return a 0 or 1 corresponding to the pin being high or low of Bit 0
// e.g. if Pin D0 is connected to +5V the variable will equal 1 
*/

*/ Reading a pi (e.g Pin D0)
int reading; // create an 8 bit variable to store pin information
reading=input(pin_d0); // return a 0 or 1 corresponding to the pin being high or low
*/

