#include <q_config.h>
#include <encoder.h>
#include <init_qmt.h>
#include <math.h>

void initialize(){
  set_tris_b(0b00000000); // sets B to outputs. B0-B1 we want for Roller
  set_tris_c(0b00000000); // sets C to outputs
  set_tris_d(0b11111111); // sets D to inputs
  setup_ccp1(CCP_PWM); // enables CCP1 to PWM mode
  setup_ccp2(CCP_PWM); // enables CCP2 to PWM mode
  setup_timer_2(T2_DIV_BY_1, 255, 1); // sets PWM frequency to 19.5kHz
  setup_adc_ports(ALL_ANALOG); // sets A and E to analog readers to the output from the A/D converter
  setup_adc(ADC_CLOCK_DIV_32); // sets A/D clock frequency
  port_b_pullups(TRUE); // adds "pull up" capability to B. Not sure what this does
}

int pwmMotors(int motor, int direction, long int duty){ // two motors, 0 or 1, direction 0,1 for forward/backward, duty[0,1023]. Returns 0 for ok, 1 error
  if (motor==0){ // first motor
    if (direction==0){ // forward direction
      output_low(pin_c3); // pin selected for motor 1 (unsure why c3 and low)
      set_pwm1_duty(duty); // set duty
    } elseif (direction==1){ //backward direction
      output_high(pin_c3); // for backwards c3 needs high instead of low, unsure why
      set_pwm1_duty(1023-duty); // duty seems to be reversed this way
    } else { // error
      return 1;
    }
  } elseif (motor==1){ //second motor
    if (direction==0){ // forward direction
      output_low(pin_c0); // pin selected for motor 2 (unsure why c0 and low)
      set_pwm2_duty(duty); //set duty
    } elseif (direction==1){ // backwards
      output_high(pin_c0); // needs high instead of low, unsure why
      set_pwm2_duty(1023-duty); // duty seems to reverse this way when backwards
    } else { // error
      return 1;
    }
  } else { //error
    return 1;
  }
  return 0; // no errors
}

void main(){
  initialize();
}
